#!/usr/bin/env python
# -*-python-*-

# please rewrite this in Go so we don't have to deal with installing a million
# Python things - currently this is blocked on the lack of a Go port of the
# WOF export library, specifically formatting (20181018/thisisaaronland)

import os
import sys
import logging
import json

import mapzen.whosonfirst.utils
import mapzen.whosonfirst.uri
import mapzen.whosonfirst.export

import collections

# cribbed from: https://gist.github.com/angstwad/bf22d1822c38a92ec0a9

def dict_merge(dct, merge_dct):
    """ Recursive dict merge. Inspired by :meth:``dict.update()``, instead of
    updating only top-level keys, dict_merge recurses down into dicts nested
    to an arbitrary depth, updating keys. The ``merge_dct`` is merged into
    ``dct``.
    :param dct: dict onto which the merge is executed
    :param merge_dct: dct merged into dct
    :return: None
    """
    for k, v in merge_dct.iteritems():
        if (k in dct and isinstance(dct[k], dict)
                and isinstance(merge_dct[k], collections.Mapping)):
            dict_merge(dct[k], merge_dct[k])
        else:
            dct[k] = merge_dct[k]

if __name__ == "__main__":

    import optparse
    opt_parser = optparse.OptionParser()

    opt_parser.add_option('-p', '--properties', dest='properties', action='store', default=None, help='...')
    opt_parser.add_option('-d', '--data', dest='data', action='store', default=None, help='...')
    opt_parser.add_option('-v', '--verbose', dest='verbose', action='store_true', default=False, help='Be chatty (default is false)')
    
    options, args = opt_parser.parse_args()

    if options.verbose:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    properties = os.path.abspath(options.properties)
    data = os.path.abspath(options.data)    

    crawl = mapzen.whosonfirst.utils.crawl(data, inflate=True)
    exporter = mapzen.whosonfirst.export.flatfile(data)
    
    for feature in crawl:

        wof_props = feature["properties"]
        wofid = wof_props["wof:id"]
        
        tree = mapzen.whosonfirst.uri.id2path(wofid)
        root = os.path.join(properties, tree)

        fname = "%s.json" % wofid        
        path = os.path.join(root, fname)

        if not os.path.exists(path):
            continue

        fh = open(path, "r")
        sfom_props = json.load(fh)

        dict_merge(wof_props, sfom_props)

        feature["properties"] = wof_props
        exporter.export_feature(feature)
        
        
